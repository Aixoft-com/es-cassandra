package com.aixoft.escassandra.aggregate;

import com.aixoft.escassandra.model.*;
import com.aixoft.escassandra.repository.model.EventDescriptor;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.UUID;

/**
 * Aggregate class which wraps aggregate data.
 *
 * @param <T> Type of aggregate data.
 */
public class Aggregate<T> extends AggregateRoot<T> {
    private T aggregateData;

    private Aggregate(UUID id) {
        super(id);
    }

    private Aggregate(Aggregate<T> aggregateBase) {
        super(aggregateBase.getId());

        aggregateData = aggregateBase.getData();
    }

    /**
     * Copies aggregate and applies all uncommitted events.
     * Both current and committed version of the new aggregate equal last event version of original aggregate.
     *
     * @return the aggregate copy with committed events.
     */
    public Aggregate<T> committedCopy() {
        Aggregate<T> aggregateCopy = new Aggregate<>(this);

        aggregateCopy.setCommittedVersion(this.getCurrentVersion());
        aggregateCopy.setCurrentVersion(this.getCurrentVersion());

        return aggregateCopy;
    }

    /**
     * Validates a command and if succeed then publishes the events generated by command.
     * <p>
     * If validation is failed (See {@link Command#validate(Aggregate)}), then events are not added to the aggregate.
     *
     * @param command Command to validated which triggers an event.
     */
    public void handleCommand(Command<T> command) {
        if (command.validate(this)) {
            for (Event event : command.toEvents(this)) {
                update(event.updater());
                publish(event);
            }
        }
    }

    /**
     * Validates a snapshot command and if succeed then publishes the event generated by command.
     * <p>
     * If validation is failed (See {@link SnapshotCommand#validate(Aggregate)}), then events are not added to the aggregate.
     * <p>
     * {@link DummyPreSnapshotEvent} is also added before snapshot to prevent race condition on aggregate save.
     *
     * @param snapshotCommand Command to validated which triggers an event.
     */
    public void handleSnapshotCommand(SnapshotCommand<T> snapshotCommand) {
        if (snapshotCommand.validate(this)) {
            publish(new DummyPreSnapshotEvent());
            publishSnapshot(snapshotCommand.toEvent());
        }
    }

    /**
     * Gets aggregate data.
     *
     * @return the aggregate data.
     */
    public T getData() {
        return aggregateData;
    }

    private void update(AggregateUpdater<T> updater) {
        aggregateData = updater.apply(aggregateData);
    }

    /**
     * Creates default Aggregate with no data by given type and UUID.
     *
     * @param id  UUID of data to be created.
     * @param <T> Type of the aggregate data.
     * @return New instance of Aggregate with given type and UUID.
     */
    public static <T> Aggregate<T> create(UUID id) {
        Aggregate<T> aggregate = new Aggregate<>(id);

        EventVersion initialVersion = EventVersion.initial();
        aggregate.setCommittedVersion(initialVersion);
        aggregate.setCurrentVersion(initialVersion);

        return aggregate;
    }

    /**
     * Restore aggregate base on provided events.
     *
     * @param <T>              Aggregate data type.
     * @param aggregateId      Aggregate UUID.
     * @param eventDescriptors Event descriptors.
     * @return restored aggregate with given type and UUID.
     */
    public static <T> Aggregate<T> restoreFromEvents(UUID aggregateId, List<EventDescriptor> eventDescriptors) {
        Aggregate<T> aggregate = new Aggregate<>(aggregateId);

        if (!eventDescriptors.isEmpty()) {
            eventDescriptors.forEach(eventDescriptor -> aggregate.update(eventDescriptor.getEvent().updater()));

            EventVersion lastEventVersion = eventDescriptors.get(eventDescriptors.size() - 1).getEventVersion();

            aggregate.setCommittedVersion(lastEventVersion);
            aggregate.setCurrentVersion(lastEventVersion);
        }

        return aggregate;
    }

    /**
     * Restore aggregate base on provided events with reactive approach.
     *
     * @param <T>              Aggregate data type.
     * @param aggregateId      Aggregate UUID.
     * @param eventDescriptors Event descriptors.
     * @return restored aggregate with given type and UUID.
     */
    public static <T> Mono<Aggregate<T>> restoreFromEvents(UUID aggregateId, Flux<EventDescriptor> eventDescriptors) {
        return eventDescriptors.reduceWith(() -> new Aggregate<T>(aggregateId),
                (aggregate, eventDescriptor) -> {
                    aggregate.update(eventDescriptor.getEvent().updater());
                    aggregate.setCommittedVersion(eventDescriptor.getEventVersion());

                    return aggregate;
                }
            )
            .doOnNext(aggregate -> aggregate.setCurrentVersion(aggregate.getCommittedVersion()));
    }
}
